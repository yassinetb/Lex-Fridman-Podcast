0:00:00
Speaker 1 :the following is a conversation with BR
 install stroke he's the creator of C++

0:00:04
Speaker 0 :

0:00:06
Speaker 1 :programming language that after 40 years
 is still one of the most popular and powerful languages in the world it'sfocused on fast stable robust code
 underlies many of the biggest systems in the world that we have come to rely onas a society if you're watching this on
 YouTube for example many of the critical

0:00:23
Speaker 0 :

0:00:24
Speaker 1 :backend components of YouTube are
 written in C++ same goes for Google Facebook Amazon Twitter most Microsoft

0:00:31
Speaker 0 :applications Adobe applications most


0:00:33
Speaker 1 :database systems and most physical
 systems that operate in the real world like cars robots rockets that launchesinto space and one day when landis on
 Mars C++ also happens to be the language that I used more than any other in mylife I've written several hundred
 thousand lines of C++ source code of course lines of source code don't meanmuch but they do give hints of my
 personal journey through the world of

0:01:03
Speaker 0 :software I've enjoyed watching the


0:01:05
Speaker 1 :development of C++ as a programming
 language leading up to the big update in a standard in 2011 and those thatfollowed in 1417 and told me the new C++
 20 standard hopefully coming out next year this is the artificial intelligence

0:01:23
Speaker 0 :

0:01:23
Speaker 1 :podcast if you enjoy it subscribe I knew
 to give it five stars and iTunes supported on patreon or simply connectwith me on Twitter Alex Friedman spelled
 Fri D ma a.m. and now here's my conversation with Bjorn straw stroke

0:01:38
Speaker 0 :

0:01:39
Speaker 1 :what was the first program you've ever


0:01:43
Speaker 0 :written do you remember it was my second
 year in university first year of computer science and it was an alcohol60 I calculated the shape of super lips
 and then connected points on the on the perimetercreating star patterns it was with a
 with a wedding on paper printer and I was in college university yeah yeah Ilearned to program the second year in


0:02:17
Speaker 1 :university and what was the first
 programming language if I may ask it

0:02:24
Speaker 0 :this way that you fell in love with I I
 think I'll call 60 and after that I remember I remember snowboardI remember Fortran didn't fall in love
 with that I remember Pascal didn't fall in love with that it all gotten away ofme and then I just covered a simpler and
 that was much more fun and from there I went to micro micro code so you were

0:02:54
Speaker 1 :drawn to the you found the low level


0:03:00
Speaker 0 :stuff beautiful I went through a lot of
 languages and then I spent significant time in in a simpler and micro code thatwas sort of the first really profitable
 things I paid for my Master's actually and then I discovered Simula which wasabsolutely great Simula simulation of
 Albert 60 done primarily for simulation but basically they invented up to Toryinto programming at inheritance and
 runtime polymorphism when they were while they were doing it and that was alanguage that taught me that you could
 have the sort of the problems of a program grow with size of the programrather than with the square of the size
 of program that is you can actually modulearise very nicely and that that that was
 a surprise to me it was also a surprise to me that a stricter type system thanPascal's was helpful whereas Pascal's
 type system got in my way all the time so you need a strong type system toorganize your code well which has to be
 extensible and flexible let's get into

0:04:21
Speaker 1 :the details a little bit what kind of if
 you remember what kind of type system to Pascal have what type system typingsystem did the Algol 60 have basically


0:04:30
Speaker 0 :Pascal was sort of the simplest language
 that Niklaus yet could define that served the needs of Niklaus Viet at thetime and it has a sort of our highly
 moral tone to it that is if you can say it in Pascal it's good and if you can'tit's not so good whereas
 Simula large is basically to build your own type system so instead of trying tofit yourself into Niklaus pierce'sworld
 Christ knew God's language and Orion dance language allowed you to build yourown so it's sort of close to the
 original idea of you you you build a domain-specific language as a matter offact what you build is a set of types
 and relations among types that allows you to express something that suitablefor an application the when you say


0:05:35
Speaker 1 :types the stuff you're saying has echoes
 of object-oriented programming

0:05:41
Speaker 0 :Kjetil they invented it every language
 that uses the word class for type is a descendant of Simula directly orindirectly Christ knew gone orientale
 were mathematicians and they didn't think in terms of type C but theyunderstood sets and classes of elements
 and so they caught their types classes and basically in C++ as in similarclasses are user defined type so can you


0:06:18
Speaker 1 :try the impossible task and give a brief
 history of programming languages from your perspective so we started withAlgol 60 Simula Pascal but that's just


0:06:33
Speaker 0 :the 60s and seven I can try
 the most sort of interesting and major improvement of programming languages wasFortran the first Fortran because before
 that all code was written for a specific machine and each specific machine had alanguage a simply language or cross
 embro or some extension of that idea but it you are writing for a specificmachine in the term in the language of
 that machine and parker's and his team at IBM built alanguage that would allow you to to
 write what you really wanted that is you can write it in a language that wasnatural for people now these people
 happen to be engineers and physicists so the language I came out was somewhatunusual for the rest of the world but
 basically they said formula translation because they wanted to have themathematical formulas translated into
 the machine and as a side effect they got portability because now theyare writing in the terms that the humans
 used and the way humans thought and then they had a program that translated itinto the machines needs and that was new
 and that was great and it's something to remember we want to raise the languageto the human level but we don't want to
 lose the efficiency so and the last

0:08:09
Speaker 1 :first step towards the human that was


0:08:12
Speaker 0 :the first step and of course they were
 very particular kind of humans business people MIT is different so they gotCOBOL instead and etc etc and simular
 came out no let's not go to simulate yet let's go to Al Gore Fortran didn't haveat the time the notions of not a precise
 notion of type not a precise notion of scope not a set of translation phasesthat was what we have today
 lexical since heck semantics it was sort of a bit of a model in the early daysbut hey they're just done the biggest
 breakthrough and history of programming right so you can't criticize them fornot having gotten all the technical
 details right so we got alcohol that was very pretty and most people in Commerceand science considered it useless
 because it was not flexible enough and it wasn't efficient enough and etc etcbut that was the breakthrough from a
 technical point of view then similar came along to make that idea moreflexible and you could define your own
 types and that's where where I got very interested first Nicole was the mainidea and behind Simula I was late 60s


0:09:43
Speaker 1 :

0:09:45
Speaker 0 :this was late 60s was a visiting
 professor in Oz and so I learned object-oriented programming by sittingaround well in theory discussing with
 with Christ Mughal but Kristin once you get started and then full flow it's veryhard to get a word in edgeways where
 you're just listed so it was great I

0:10:13
Speaker 1 :learned it from them not to romanticize
 the notion but it seems like a big leap to think about object-orientedprogramming it's really a leap of


0:10:23
Speaker 0 :

0:10:25
Speaker 1 :abstraction it's yes and was that as big
 and beautiful of a leap as it seems from now in retrospect I was in an obvious

0:10:36
Speaker 0 :one at the time it was not obvious and
 many people have tried to do something like thatand most people didn't come up with
 something as wonderful as similar lots of people got their PhDs and made theircareers out of forgetting about Simula
 or never knowing it for me the key idea was basically I could get my own typesand that's the idea that goes for a
 lines of C++ where I can get better types and more flexible types and moreefficient types but it's still the
 fundamental idea when I want to write a program I want to write it with my typesthat is appropriate to my problem and
 under the constraints that I'm under with hardware software environment etcand that's that's the key idea people
 picked up on hierarchy is in the virtual functionsand the inheritance and that was only
 part of it it was an interesting and major part and still a major part and alot of graphic stuff but it was not the
 most fundamental it it was when you wanted to relate one type to another youdon't want the more to be independent
 that the classical example is that you don't actually want to write citysimulation with vehicles where you say
 well if it's a buy signal to write the code for turning a bicycle to the leftif it's a normal car turn right a normal
 car way if it's a fire engine and right the fire engine way da da da da da youget these big case statements and
 bunches of if statement and such instead you tell the other the baseclass that that's the Viacom saying turn
 turn left the way you want to and this is actually a real example they theyused it to simulate and optimize the
 emergency the emergency services for somewhere Norwayback in the 60s Wow so this was one of
 the early examples for why you needed inheritance and and you needed runtimepolymorphism because you wanted to
 handle this set of vehicles in a manageable way you you you can't justrewrite your code each time a new kind
 of vehicle comes along yeah that's a

0:13:19
Speaker 1 :beautiful powerful idea and of course
 that it stretches through your work who C++ as we'll talk about but I think youstructured it nicely
 what other breakthroughs came along in the history of programming languagesthey if we were to tell the history in


0:13:38
Speaker 0 :that way obviously I'm bitter telling
 the part of the history that that is the path I'm on as opposed to all the path

0:13:46
Speaker 1 :yeah you skipped the hippy
 John McCarthy and Lisp or my favorite

0:13:51
Speaker 0 :languages but listen what Lisp is not
 one of my favorite language yes it's obviously important it's obviouslyinteresting lots of people write code in
 it and then they rewrite it into C or C++ when they want to go to productionyes it's in the world
 I met which are constrained by performance reliability issuesdeployability cost of hardware I I don't
 like things to be too dynamic it is really hard to write a piece of codethat's perfectly flexible that you can
 also deploy on a small computer and that you can also put in say a telephoneswitch in Bogota what's the chance if
 you get an error and you find yourself in the debugger that the telephoneswitch in pockets are on late Sunday
 night has a programmer around right their chance is zero and so a lot ofthings I think most about can't afford
 that flexibility and I'm quite aware that maybe 70 80 percent of all code arenot under the kind of constraints I'm
 interested in but somebody has to do the job I'm doing because you have to getfrom these high level flexible languages


0:15:21
Speaker 1 :to the hardware the stuff that lasts for
 10 20 30 years is robust yeah operates under very constrainedconditions yes absolutely that's right
 and it's fascinating and beautiful in its own way it's C++ is one of myfavorite languages and so is Lisp
 so I can I can embody two for different reasons as as a programmer I understand

0:15:46
Speaker 0 :why it is popular and I can see the
 beauty of the ideas and similarly with this more talkit's just know this relative thank it
 it's not as relevant in my world and by the way I distinguish between those andthe functional languages where I go to
 things like ml and Hesco different different kind of languages they have adifferent kind of huge in there very
 interesting and I actually try to learn from all the languages I encounter tosee what is layer that would make
 working on the kind of problems I'm interested in with the kind ofconstraints that that I'm interested in
 what can actually be done better because we can surely do better than we do today

0:16:45
Speaker 1 :you've you've said that it's good for
 any professional programmer to know at least five languages speaking about avariety of languages that you've taken
 inspiration from and you've listed the yours as being at least at the time C++obviously Java Python Ruby and
 JavaScript can you first of all update that list modify it if you don't have tobe constrained to just five but can you
 describe what you picked up also from each of these languages how you see themas inspirations for even you're working


0:17:25
Speaker 0 :with C++ this is a very hard question to
 answer so about languages you should knowlanguages I I reckon I knew about
 twenty-five or there abouts when I did C++ it was easier than those daysbecause the languages were smaller and
 you didn't have to learn a whole programming environment and such to doit you you could learn the language
 quite easily and it's good to learn so

0:17:55
Speaker 1 :many languages and I imagine just like
 with natural language for communication there's different paradigms that emergein all of them yeah that there's


0:18:08
Speaker 0 :commonalities and so on so I picked fire
 out of a head so far ahead obviously well the important thing that the numberis not one that's right it's like I
 don't like I mean if you're mono clot you are likely to think that your ownculture is the only ones peer is
 everybody else's a good learning of a foreign language and a foreign cultureis important it helps you think and be a
 better person with programming languages you become a better programmer betterdesigner with the second language now
 once you've got to the wage of five is not that long it's the second one that'smost important and then when I had to
 pick five I sort of thinking what kinds of languages are there well there's areally low level stuff it's good it's
 actually good to know machine code movie

0:19:05
Speaker 1 :

0:19:05
Speaker 0 :very still sorry even today even today
 the C++ optimizer is right there a machine code than I doyes but I don't think I could appreciate
 them if I actually didn't understand machine code and machine architecture atleast in in my position I have to
 understand a bit of it because you mess up the cash and you're off inperformance by a factor of a hundred
 right shouldn't be that if you are interested in higher performance or thesize of the computer you have to deploy
 so so I would go there's a simpler I used to mention C but these days goinglow-level is not actually what gives you
 the performance it is to express your ideas so cleanly that you can thinkabout it and the optimizer can
 understand what you're up to my favorite way of optimizing these daysis to throw out the clever bits and see
 if it's dawn runs fast and sometimes it runs faster so I need the abstractionmechanisms or something like C++ to
 write compact high-performance code there was a beautiful keynote by JasonTurner
 the CPP con a couple of years ago where he decided he was going to program pongon Motorola 6800 I think it was and he
 says well this is relevant because it looks like a microcontroller it hasspecialized hardware it has not very
 much memory and it's relatively slow and so he shows in real time how he writespong starting with fairly
 straightforward low-level stuff improving his abstractions and what he'sdoing he's writing C++ and it translate
 into in 286 assembler which you can do withplaying and you can see it in real-time
 it's the compiled explora which you can use on the web and then he wrote alittle program that translated 86
 assembler into Motorola has simpler and so he types andyou can see this thing in real time
 while you can see it in real time and even if you can't read the assembly codeyou can just see it
 his code gets better the code the assembler gets Kimura he increases theabstraction level uses C++ 11 as it were
 better this code gets clean that gets easier maintain the code shrinks and itkeeps shrinking and I could not in any
 reasonable amount of time write that a simpler as good as the compilergenerated from really a quite nice
 modern C++ and I'll go as far as to say the the thing that looked like C wassignificantly uglier and and smaller
 when it becames and and larger when it became machinecode so what the the abstractions that
 can be optimized important I would love

0:22:26
Speaker 1 :to see that kind of visualization larger
 code bases yeah there might be blood a

0:22:32
Speaker 0 :few can't show a larger code base in a
 one-hour talk and to have it fit on

0:22:38
Speaker 1 :screen right so that C is if you love so


0:22:40
Speaker 0 :my two languages would be machine code
 and C++ and then I think you can learn a lot from the functional languages so pighas pralaya male I don't care which I
 think actually you you'll you'll learn the same lessons of expressingespecially mathematical notions really
 clearly and having the type system that's really strict and then you shouldprobably have a language for sort of
 quickly churning out something you could pick JavaScript you could pick Python

0:23:19
Speaker 1 :you could pick Ruby really make of
 JavaScript in general so you kind of you're talking in the Platonic sense ofall languages about what they're good at
 what their philosophy design is but there's also a large user base behindeach of these languages and they use it
 in the way maybe it wasn't really designed forthat's right javascript is used way
 beyond I probably put hooks design for

0:23:43
Speaker 0 :it let let me say it this way when you
 build a tool you do not know how it's going to be used you try to improve thetool by looking at how it's being used
 and when people cut their fingers off and try and stop that from happening butreally you have no control over how
 something is used so I'm very happy and proud of some of the things he plusplaus being used at and some of the
 things I wish people wouldn't do Bitcoin mining being my favorite example uses asmuch energy as Switzerland and mostly
 serves criminals yeah but back to back to the languages I actually think thathaving JavaScript run in the browser
 what was was an enabling thing for a lot of things yes you could have done itbetter but people were trying to do it
 better they were using proof sort of more principles language designs butthey just couldn't do it right and the
 non professional programmers that write or lots of that code just couldn'tunderstand them so it did
 amazing job for what it was it's not the prettiest language and I don't think itever will be the prettiest language but
 that's not be bigots here so what was

0:25:07
Speaker 1 :the origin story of C++ you you


0:25:11
Speaker 0 :

0:25:12
Speaker 1 :basically gave a few perspectives of
 your inspiration of object-oriented programming that's you had a connectionwith C in performance efficiency was an
 important thing you were drawn to

0:25:27
Speaker 0 :efficiency and reliability reliability
 you have to get both what

0:25:31
Speaker 1 :

0:25:34
Speaker 0 :what's reliability I I really want my
 telephone calls to get through and I want the quality of what I am talkingcoming out with the other end the other
 end might be in London or wherever so and you don't want the system to becrashing if you're doing a bank here is
 you must not crash it might be your your bank account that is in trouble there'sdifferent constraints like in games it
 doesn't matter too much if there's a crash nobody dies and nobody gets ruinedbut I am interested in the combination
 of performance partly because of sort of speed of things being done part of beingable to do things that is necessary to
 do to have reliable energy of larger systems if you spend all your timeinterpreting a simple function call you
 are not going to have enough time to do proper signal processing to get thetelephone calls to sound right I know
 that or you have to have 10 times as many computers and you can't afford yourphone anymore it's a ridiculous idea in
 the modern world because we have solved all of those problems I mean they keep

0:26:54
Speaker 1 :popping up in different ways as we
 tackle bigger and bigger problems efficiency remains always an important

0:27:03
Speaker 0 :aspect but you have to think about
 efficiency not just as speed but as an enabler tothings and women thinks it enables is
 this reliability is dependability you won when I press the pedal the brakepedal of a car it is not actually
 connect it directly to to anything but a computer that computer better work let's

0:27:31
Speaker 1 :talk about reliability just a little bit
 so modern cars have ECU's millions of lines of code Mmeso this is certainly especially true of
 autonomous vehicles where some of the aspects of the control or driverassistance systems that steer the car
 the key panel and so on so how do you think you know I talk to regulatorspeople in government who are very
 nervous about testing the safety of

0:28:00
Speaker 0 :

0:28:01
Speaker 1 :these systems of software ultimately
 software that makes decisions that could lead to fatalities so how do you how dowe test software systems like these


0:28:12
Speaker 0 :first of all safety like performance and
 like security is a systems property people tend to look at one part of asystem at a time and saying something
 like this is secure that's all right I don't need to do that yeah that piece ofcode is secure I'll buy your operator
 right if you want to have reliability if you want to have performance if you wantto have security you have to look at the


0:28:46
Speaker 1 :whole system I did not expect you to say
 that but that's very true

0:28:49
Speaker 0 :yes I'm dealing with one part of the
 system and I want my part to be really good but I know it's not the wholesystem furthermore if making an
 individual part perfect may actually not be the best way of getting the highestdegree of reliability and performance
 and such the spumone says super cross type say not type safe you can break itsure I can break anything that runs on a
 computer I may not go through your type systemif I wanted to break into your computer
 I'll probably try SQL injection and it's

0:29:28
Speaker 1 :very true if you think about safety or
 even reliability at its system level especially when a human being isinvolved it's starts becoming hopeless
 pretty quickly in terms of proving that something is safe to a certain levelyeah there's so many variables it's so


0:29:52
Speaker 0 :complex well let's get back to something
 we can talk about and it actually makes some progress on yes we look at C++programs and we can try and make sure
 the crash less often the way you do that is largely by simplification it is notthe first step is to simplify the code
 have less code have code that are less likely to go wrong it's not by runtimetesting everything it is not by big test
 frameworks that you're using yes we do that also but the first step is actuallyto make sure that when you want to
 express something you can express it directly in code rather than goingthrough endless loops and convolutions
 in your head before it gets down the code that if if the way you are thinkingabout a problem is not in the code there
 is a missing piece that's just in your head and the code you can see what itdoes but it cannot see what you thought
 about it unless you have expressed things directly when you express thingsdirectly you can maintain it
 it's these years to find errors is easier to make modifications it'sactually easier to test it and lo and
 behold it runs faster and therefore you can use a smallernumber of computers which means there's
 less hardware that could possibly break so I think the key here issimplification but it has to be to use
 the Einstein code as simple as possible

0:31:39
Speaker 1 :and no simpler not simpler well there


0:31:42
Speaker 0 :are other areas with under constraints
 where you can be simpler than you can be in C++ but in the domain I'm dealingwith
 that's the simplification I'm after so

0:31:53
Speaker 1 :how do you inspire or ensure that the
 Einstein level simplification is reached so okay can you do code review can youlook at code is there if I gave you the
 code for the Ford f-150 and said here is this a mess or is this okay is itpossible to tell is it possible to


0:32:21
Speaker 0 :regulate an experienced developer can do
 it code and see if it smells you know I'm mixed metaphors deliberately yes thethe point is that it is hard to generate
 something that is really obviously clean and can be appreciated but you canusually recognize when you haven't
 reached that point and so if I I've never looked at me if 150 code so Iwouldn't know but but I know what I
 ought to be looking for there I'll be looking for some tricks that correlateswith bugs and elsewhere and I have tried
 to formulate rules for what what good code looks like and the current versionof that is called the C++ core
 guidelines one thing people should remember isthere's what you can do in a language
 and what you should do in a language you have lots of things that is necessary insome context but not another's as things
 that exist just because there's 30 year old code out there and you can't get ridof it but you can't have rules it says
 when you create it try and follow these rules this does not create good programsby themselves but it limits the damage
 and off for mistakes it limits the possibilities of the mistakes andbasically we are trying to say what is
 it that a good programmer does at the fairly simple level of where you use thelanguage and how you use it now I can
 move all the rules for chiseling in my marble it doesn't mean that somebody whofollows all of those rules can do a
 masterpiece by Machine Angelo that is there something else to write agood program just is there something
 else to create important work of art that is there's some kind of inspirationunderstanding gift but we can approach
 the sort of technical the the craftsmanship level of it the the thefamous painters the famous cultures was
 among other things superb craftsmen they could expresstheir ideas using their tools very well
 and so these days I think what I'm doing what a lot of people are doing we'restill trying to figure out how it is to
 use our tools very well for a really good piece of code you need a spark ofinspiration and you can't
 I think regulate that you you cannot say that I'll take a pictureonly I'll buy your picture only if
 you're at least then go there are things you can regulate but not the inspiration

0:35:50
Speaker 1 :I think that's quite beautifully put it
 is true that there is there's an experienced programmer when you see codethat's inspired that's like Michelangelo
 you know it when you see it and the opposite of that is code that ismessy code that smells you know when you
 see it and I'm not sure you can describe it in words except vaguely through

0:36:19
Speaker 0 :guidelines and so on yes it's easier to
 recognize ugly than to recognize beauty in code and for the reason is thatsometimes beauty comes from something
 that's innovative and unusual and you have to sometimes think reasonably hardto appreciate that
 on the other hand the misses have things in common and you can you can havestatic checkers dynamic checkers that
 finds large number of the most common mistakes you can catch a lot ofsloppiness mechanically I'm a great fan
 of static analysis in particular because you can check for not just the languagerules but for the usage of language
 rules and I think we will see much more static analysis in the coming decade

0:37:18
Speaker 1 :clear the drive word static analysis you


0:37:21
Speaker 0 :represent a piece of code so that you
 can write a program that goes or that representation and look for things thatare right and not right so for instance
 you can analyze a program to see if resources are leaked that's one of myfavorite problems it's not actually all
 that hard and one C++ but you can do it if you were writing in the C level youhave to have a Murloc and a free and
 they have to match if you have them in a single function you can usually do itvery easily if there's a man log here
 there should be a free there on the other hand in between can be drawingcomplete code and then it becomes
 impossible yeah if you pass that pointer to the memory out of a function and thenwant to make sure that the free is done
 somewhere else now it gets really difficult and so for static analysis youcan run through a program and you can
 try and figure out if there's any leaks and what you will properly find is thatyou will find some leaks and you'll find
 quite a few places where your analysis can't be complete it might depend onruntime it might
 depend on the cleverness of your analyzer and it might take a long timesome of these programs run for a long
 time but if you combine such analysis with a set of rules it says how peoplecould use it you can actually see why
 the rules are violated and that stops you from getting into the impossiblecomplexities you don't want to solve the


0:39:28
Speaker 1 :halting problem the static analysis is
 looking at the code without running the code yes and thereby it's almost not inproduction code but it's almost like an
 educational tool of how the language should be used it's guys you like it isbest right it would guide you in how you
 write future code as well and you learn

0:39:52
Speaker 0 :together yes so basically you need a set
 of rules for how you use the language then you need a static analysis thatcatches your mistakes when you violate
 the rules or when your code ends up doing things that it shouldn't despitethe rules because there's the language
 rules you can go further and again it's back to my idea that I would much ratherfind errors before I start running the
 code if nothing else once the code runs if it catches an error at run times Ihave to have an error handler and one of
 the hardest things to write in code is their handling code because you knowsomething went wrong
 do you know really exactly what went wrong usually not how can you recoverwhen you don't know what the problem was
 you can't be a hundred percent sure what the problem was in many many cases andthis is this is part of it so yes we
 need good languages or good type systems we need rules for how to use them weneed static analysis and the ultimate
 for static analysis is of course program proof but that still doesn't scale sothe kind of systems we deploy
 then we start needing testing and the

0:41:15
Speaker 1 :rest of the stuff so C++ is an
 object-oriented programming language that creates especially with its newerversions as we'll talk about higher and
 higher levels of abstraction so how do you design let's even go back to theorigin C++ how you design something with
 so much abstraction that's still efficient and is still something thatyou can manage do static analysis on you
 can have constraints on they can be reliable those things we've talked aboutso create the to me slightly there's a
 slight tension between high-level abstraction and efficiency that's a good

0:42:00
Speaker 0 :question I could probably have a year's
 course just trying to answer it yes there's a tension between efficiency andabstraction but you also get the
 interesting situation that you get the best efficiency out of the bestabstraction and my main tool for
 efficiency for performance actually is abstraction so let's go back to how C++got there yeah you said it was up to
 Rory in the programming language I actually never said that it's alwaysquoted but I never did I said C++
 supports object-oriented programming but it's nine other techniques and thatthat's important because I think that
 the best solution to most complex interesting problems require ideas andtechniques from things that has been
 called object-oriented data abstraction function or traditional C style code allof the above and so when I was designing
 C++ I soon realized I couldn't just add featuresif you just add what looks pretty or
 what people ask for or what you think is good one by one you're not going to geta coherent whole what you need is a set
 of guidelines that that that guides your decisions should this feature Viennashould this feature be out how should a
 feature be modified before it can go in and such and there's a in in the book Iwrote about that that sign evolution of
 si+ process a whole bunch of rules like that most of them are not languagetechnical they they they're they're
 things like don't violate static type system because I like static type systemfor the obvious reason that I like
 things to be reliable on reasonable amounts of hardwarebut one of these rules is the zero
 overhead principle the were kind of put a zero overhead principle it basicallysays that if you have an abstraction it
 should not cost anything compared to write the equivalent code at a lowerlevel so if I have say a matrix
 multiplied it should be written in such a way that you could not drop to the Clevel of abstraction and use arrays and
 pointers and such and run faster and so people have written such matrixmultiplications and we have actually
 gotten code that ran faster than Fortran because once you had the rightabstraction you can eliminate you can
 eliminate temporaries and you can do loop fusion and other good stuff likethat that's quite hard to do by hand and
 in a lower level language and there's some really nice examples of that andthe key here is that that matrix
 multiplication the matrix abstraction allows you to write code that's simpleand easy you can do that in any language
 but with C++ it has the features so that you can also have this thing run fasterthan if you hand coded it now people
 have given that lecture many times I and others and a very common on questionafter the talk where you have
 demonstrated that you can outperform Fortran for dense matrix multiplicationpeople come up and says yeah but there
 are C++ if I rewrote your code and see how much faster would have run theanswer is much slower this happened the
 first time actually back in the ages with a friend of mine called DougMcIlroy who demonstrated exactly this
 effect and so the principle is you should give programmers the tools sothat the abstractions can follow the 0oi
 principle furthermore when you put in a languagefeature in C++ or a standard library
 feature you try to meet this it doesn't mean it's absolutely optimal but itmeans if you're hand coded with the
 usual the facilities in the language in C++ in C you should not be able tobetter it usually you can do better if
 you use embedded a simpler for machine code for some of the details to utilizepart of a computer that the compiler
 doesn't know about but you should get to that point before you be to the

0:47:08
Speaker 1 :abstraction so that's that's a beautiful
 ideal to reach for and we meet it quite

0:47:12
Speaker 0 :

0:47:14
Speaker 1 :often quite often so where's the magic
 of that coming from there's some of it is the compilation process so theimplementation is C++ some of it is the
 design of the feature itself the guidelines so I've recently an oftentalk of Chris Ladner so clang what just
 out of curiosity is your relationship in general with the differentimplementations in C++ as you think
 about you and committee and other people C++ think about the design of newfeatures or design of previous features
 the in in trying to reach the ideal of zero overhead who does the magic comefrom the design the guidelines or from


0:48:06
Speaker 0 :the implementations and and not all you
 have you you are you you you you go for programming technique program languagefeatures and implementation techniques


0:48:18
Speaker 1 :you need all three and how can you think
 about all three at the same time it

0:48:23
Speaker 0 :takes some experience takes some
 practice and sometimes you get it wrong but after a while you sort of get itright I don't write compilers anymore
 but Brian Kearney and pointed out that oneof the reason c++ succeeded was some of
 the craftsmanship I put into the early compilers and of course I did thelanguages sign of course I wrote a fair
 amount of code using this kind of stuff and I think most of the successesinvolves progress in all three areas
 together a small group of people can do that two three people can can worktogether to do something like that it's
 ideal if it's one person that has all the skills necessary but nobody has allthe skills necessary in all the fields
 where C++ is used so if you want to approach my idea in say concurrentprogramming you need to know about
 algorithms of my current programming you need to know the the triggering oflock-free programming you need to know
 something about compiler techniques and then you have to know some of theprogram error the sorry the application
 areas what this is like some forms of graphics or some forms of what arecalled the web server and kind of stuff
 and that's very hard to get into a single head but small groups can do it

0:50:01
Speaker 1 :too it says there differences in your
 view not saying which is better or so on but difference in the differentimplementations of C++ why are there
 several sort of many of you naive questions for meGCC clang so this is a very reasonable


0:50:20
Speaker 0 :question when I designed C++
 most languages have multiple implementations because if you wanna Ip.m. if you run on a Sun if you wanna
 Motorola that those just many many companies and they each have their owncompilation structure the old compilers
 it was just fairly common that those many of them and I wrote C frontassuming that other people would write
 compilers for C++ if I was successful and furthermore I wanted to utilize allthe backend infrastructure were
 available I soon realized that my users were using 25 different linkers Icouldn't write my own linker yes I could
 but I couldn't write 25 linkers and also get any work done on the language and soit came from a world where there was
 many linkers many optimizers many compiler front ends not not to start butover at many operating systems the whole
 world was not an 86 and linux box or something whatever is the standard todayin the old days they said a set of X so
 basically I assumed there'd be lots of compilers it was not a decision thatthere should be many compilers it was
 just a fact that's the way the world is and yes many compilers emerged and todaythere's at least four front ends playing
 GCC Microsoft and EDG it is Design Group they they supply a lot of theindependence organizations and the
 embedded systems industry and there's lots and lots of backends we have tothink about how many dozen begins there
 are because different machines have different things especially in theembedded world their machines are very
 different the architectures are very differentand so having a single implementation
 was never an option now I also happen to dislike

0:52:52
Speaker 1 :monocultures monocultures they are


0:52:54
Speaker 0 :dangerous because whoever owns the
 monoculture can go stale and there's no competition and there's no incentive toinnovate there's a lot of incentive to
 put barriers in the way of change because hey we own the world and it's avery comfortable world for us and who
 are you to to mess with that so I really am very happy that this for front-endsfor C++ clanks great but GCC was great
 but then it got somewhat stale Tran came along and GCC's much better nowcompetition my Microsoft is much better
 now so hello at least a low number our frontend puts a lot of pressure on
 stand-ups compliance and also on performance and error messages andcompile time speed all this good stuff


0:54:00
Speaker 1 :that we want do you think crazy question
 there might come along you hope that might come along implementation of C++written given all its history written
 from scratch so written today from

0:54:18
Speaker 0 :scratch well playing and the LLVM this
 more less written by from scratch but

0:54:24
Speaker 1 :there's been c++ 11 14 17 20 you know


0:54:30
Speaker 0 :there's been a lot you know later
 somebody's going to try again there has been attempts to write new C++ compilersand some of them has been used and some
 of them has been absorbed into others and so yeah I don't happen so what are

0:54:46
Speaker 1 :the key features of C++ and let's use
 that as a way to sort of talk about the evolution of C++ the new feature so atthe highest level what are the features
 that were there in the beginning what

0:55:03
Speaker 0 :features got added its first get a
 principal on aim in place C++ is for people who want to use hardware reallywell and then manage the complexity of
 doing that through abstraction and so the first facility you you have is a wayof manipulating the machines at a fairly
 low level that looks very much like see it has loops it has variables it haspointers like machine addresses it can
 access memory directly it can allocate stuff in the absolute minimum of spaceneeded on the machine there's a machine
 facing part of C++ which is roughly equivalent to C I said C++ could beat Cand it can doesn't mean I dislike see if
 I disliked C wouldn't have built on it furthermoreafter Dennis Ritchie I'm probably the
 major contributor to modern C and well I had lunch with Dennis most days for 16years and we never had a harsh word
 between us so these C versus C++ fights are for people who don't quiteunderstand what's going on then the
 other part is the abstraction and there the key is the class which is a userdefined type and my idea for the class
 is that you should be able to build a type that's just like the building typesin in the way you use them in the way
 you declare them and the way you get the memory and you can do just as wellso in C++ there's an int as in C you
 should be able to build an abstraction a class which we can call capital int thatyou could use exactly like an integer
 and run just as fast as an integer there's the idea right there and ofcourse you probably don't want to use
 the int itself but it has happened people have wanted integers that wererange checked so that you couldn't
 overflow one such especially for very safety critical applications like thefuel injection for a marine diesel
 engine for the largest ships this is a real example by the way this has beendone they they built themselves an
 integer that was just like integer except that couldn't overflow if there'sno or flow you went into the error
 handling and then you built more interesting types you can build a matrixwhich you need to do graphics or you
 could build a gnome for a for a video

0:58:04
Speaker 1 :game and all these are classes and they
 appear just like the built-in types exciting terms of efficiency and so on

0:58:11
Speaker 0 :so what else is there and flexibility so


0:58:14
Speaker 1 :

0:58:14
Speaker 0 :

0:58:16
Speaker 1 :I don't know for people who are not
 familiar with object-oriented programmingthere's inheritance there's a hierarchy
 of classes you you can just like you said create a generic vehicle that can

0:58:29
Speaker 0 :turn left so what people found was that
 you don't actually know how do I say thisa lot of types are related that is the
 vehicles all the accounts are related bicycles cars fire engines tanks theyhave some things in common and some
 things that differ and you would like to have the common things common and havingthe differences specific and when you
 didn't want to know about the differences like just turn leftuuuuu you don't have to worry about it
 that's how you get the traditional object-oriented programming coming outof simulate opted by small talk and C++
 and all the other languages the other kind of obvious similarity between typescomes when you have something like a
 vector fortune gave us the vector as called array of doubles but the minuteyou have a vector of doubles you want a
 vector or double precision doubles and for short doubles for graphics and whyshould you have not have a vector of
 integers while you're added or vector of vectors and vector of vectors of chesspieces now we have a board right so this
 is you express array the commonality as the idea of a vector and the variationscome through parameterization and so
 here we get the two fundamental ways of abstracting or of having similarities oftypes in C++
 there's the inheritance and there's a parameterizationthere's the object-oriented programming
 in this generic programming

1:00:28
Speaker 1 :with the templates for the generic
 program yeah so you you've presented it very nicely but now you have to make allthat happen and make it efficient so
 generic programming with templates there's all kinds of magic going onespecially recently that you can help
 catch up on but it feels to me like you can do way more than what you just saidwith templates you can start doing this
 kind of meta programming this kind you

1:00:58
Speaker 0 :can do meta programming also I I didn't
 go there and in that explanation we're trying to be very basics but go back onso the implementation implementation if
 you couldn't implement this efficiently if you couldn't use it so that it becameefficient it has no place in C++ because
 it were violates the zero overhead principle so when I had to get up duringprogramming inheritance I took the idea
 of virtual functions from Simula virtual functions is a similar term class is asimilar term if you ever use those words
 say thanks to question you go and all you and I'll and I did the simplestimplementation I knew off which was
 basically a jump table so you get the virtual function table or the functiongoes in do it does an indirection
 through a table and get the right function that's how you pick the rightthing there and I thought that was
 trivial it's close to optimal it's endo is obvious it turned out the Simula hada more complicated way of doing it
 therefore slower and it turns out that most languages have something that's alittle bit more complicated sometimes
 more flexible but you pay for it and one of the strengths of C++ was that youcould actually do this object-oriented
 stuff and your overhead compared to ordinary functions there's nointeractions it's not open five ten
 twenty five percent for just the core it sits down there it's not tooand that means you can afford to use it
 furthermore in C++ you have the distinction between a virtual functionand a non-virtual function if you don't
 want any overhead if you don't need the interaction that gives you theflexibility in object-oriented
 programming just don't ask for it so the idea is that you only use virtualfunctions if you actually need the
 flexibility so it's not zero overhead but zero overhead compared to any otherway of achieving the flexibility now
 also parameterization basically the compiler looks at at the the templatesay the vector and it looks at the
 parameter and then combines the two and generates a piece of code that isexactly as if you're written a vector
 off that specific type yes so that's the that's the minimal overhead if you havemany template parameters you can
 actually combine code that the compiler couldn't usually see at the same timeand therefore get code that is faster
 then if you had handwritten stuff on this you are very very clever so the

1:04:05
Speaker 1 :thing is Parature i's code the compiler
 fills stuff in during the compilation process not during runtime that's right

1:04:15
Speaker 0 :and so in furthermore it gives all the
 information it's gotten which is the template the parameter and the contextof use it combines the three and
 generates good code but it can generate

1:04:31
Speaker 1 :now it's a little outside of what I'm
 even comfortable thinking about but it

1:04:39
Speaker 0 :can generate a lot of code yes and how


1:04:41
Speaker 1 :do you remember being both amazed at the
 power of that idea and how ugly the debugging look

1:04:53
Speaker 0 :the debugging can be truly horrid come
 back to this because I have a solution anywaythe debugging was ugly the code
 generated by C++ has always been ugly because there's these inherentoptimizations a modern C++ compiler has
 runned in middle-end and beckoned optimizations even C front back in 83had front end and back end optimizations
 I actually took the code generated an internal representation munch thatimplements a representation to generate
 good code so people says it's not a compiler I generate see if the reason itgenerated C was a one that you used to
 C's code generators that are really good at backend optimizations but I need afront end of two eyes Asians and
 therefore the C I generated was optimized C hmm the way really good up ahandcrafted optimize a human who could
 could generate it and it was not meant for humans it was the output of aprogram and it's much worse today and
 with templates it gets much worse still so it's hard to do it's hard to combinesimple debugging with simple with the
 optimal code because the idea is to drag in information from different parts ofthe code to generate good code machine
 code and that's not readable so what people often do for debugging is theyturn the optimizer off and so you get
 code that when you when when something in your source code looks like afunction call it is a function call when
 the optimizer is turned on it may disappear the function call it mayinline and so one of the things you can
 do is you can actually get code that is smaller than the function call becauseyou eliminate the function preamble and
 returned and that's just the operation there one of the key things when I didtemplates was I wanted to make sure that
 if you have say a sort algorithm and you give it a sorting criteria if thatsorting criteria is simply comparing
 things with lesson the code generators should be the lessthan not a indirect function call to a
 compression object which is what it is in the source code but we really wantdown to the single instruction and but
 anyway turn off the optimizer and and you can you can debug the first level ofdebugging can be done and I always do
 without the optimization on because then I can see what's going on and then

1:08:02
Speaker 1 :there's this idea of concepts that puts


1:08:04
Speaker 0 :

1:08:06
Speaker 1 :

1:08:07
Speaker 0 :

1:08:08
Speaker 1 :some now I've never even the I don't
 know if it was ever available in any form but it puts some constraints on thestuff you can parameterize essentially


1:08:20
Speaker 0 :let me try and explain yes so yes it
 wasn't there ten years ago we have had versions of it that actually work forthe last four or five years it was a
 design by Gabby does raise true certain and me we were professors and postdocsin Texas at the time and the
 implementation by Andrew Sutton has been available for at that time and it ispart of C++ 20 and the standard library
 that uses it so this is becoming really very real it's available in clang andGCC GCC for a couple of years and I
 believe Microsoft zum-zum going to do it expect a wall of C++ 20 to beavailable so in all the major compilers
 in 20 but this kind of stuff is it's available now I'm just saying thatbecause otherwise people might think I
 was talking about science fiction and so what I'm going to say Israel on Creteyou can write it today
 and there's production users of it so the basic idea is that when you have a ageneric component like a sort function
 the sort function will will require at least two parameters one a datastructure with a given type and
 comparison criteria and these things are related but obviously you can't comparethings if you don't know what the type
 of things you compare and so you want to be able to say I'mgoing to sort something and did this to
 be sortable what does it mean to be sortable you look it up in the standardit has to have it has to be a sequence
 with a beginning and an end there has to be random access to that sequence andthere has to be the element types has to
 be comparable like you more like an

1:10:39
Speaker 1 :operator can I do it yes what illogical


1:10:42
Speaker 0 :already cannot basically what concepts
 are there compile-time predicates there predicates you can ask are you asequence yes I have begin an end
 are you a random exit sequence yes I have subscripting and plus it's yourelement type something that has a less
 then yes I have a less than hits and so basically that's the system and soinstead of saying I will take a
 parameter of any type it'll say I'll take something that's audible and it'swell defined and so we say okay you can
 sorta less then I don't want less then I want greater then also something Iinvent so you have two parameters the
 sortable thing and the compassion criteria and the comparison criteriawill say well I can you you can write it
 saying it should operate on the element type and it has the compassionoperations so that's the simply the
 fundamental thing it's compile-time predicates do you have the properties Ineed so it specifies the requirements of
 the code on the parameters that gets yes there are lots of types actually but

1:12:03
Speaker 1 :operating in the space of concepts


1:12:07
Speaker 0 :concepts the word concept was used by
 Alec Stephan of who is sort of the father of generic programming in thecontext of C++
 there's other places that use that word but the way we call Genetic Programmingis Alex's and he called them concepts
 because he said there they are the sort of the fundamental concepts of an areaso they should be called concepts and
 we've had concepts all the time if you look at the knr book about si si hasarithmetic types and it has integral
 types it says so in the book and then it lists what they are and they havecertain properties the difference today
 is that we can actually write a concept that will ask a type are you an integraltype do you have the properties
 necessary to be an integral type do you have Proust - divide so what may be the

1:13:09
Speaker 1 :story of concepts because I thought it
 might be part of C++ 11 C C C's o X or whatever it was at the time what was thewhy didn't it look like what we'll talk
 a little bit about this fascinating process of standards because I thinkit's really interesting for people it's
 interesting for me but why did it take so long what shapes the the idea ofconcepts take what were the challenges


1:13:43
Speaker 0 :back in 87 of there abouts 97 well 1987


1:13:48
Speaker 1 :

1:13:49
Speaker 0 :like they are about so when I was
 designing templates obviously I wanted to express the notion of what isrequired by a template of its arguments
 and so I looked at this and basically for for templates I wanted threeproperties I wanted to be very flexible
 it had to be able to express things I couldn't imagine because I know I can'timagine everything and I've been
 suffering from languages and try to constrain you to only do what you're thedesigner thought good didn't want to do
 that secondly it had to run fasteras faster faster that hand written code
 so basically if I have a vector of T and I take a vector of cha it should run asfast as you built a vector of cha
 yourself without parameterization and second and thirdly I wanted to be ableto express the constraints of of the
 arguments have proper type checking of the interfaces and neither I nor anybodyelse at the time knew how to get all
 three and I thought for C++ I must have the two first otherwise it's not C++ andit bothered me for an hour a couple of
 decades that I couldn't solve the third one I mean I was the one that putfunction argument type checking in to
 see I know the value of good interfaces I didn't invent that idea it's verycommon but I did it and I wanted to do
 the same for templates of course and I could so it bothered me then we try itagain
 mm of to 2003 cavitus raised and I started analyzingthe problem explained possible solutions
 there was not a complete design a group in University of Indiana an old friendof mine they started a project at
 Indiana and we thought we could get a good system of concepts in another twoor three years that would have made C++
 la 11 to C++ Oh 607 well it turns out that I think we got a lot of thefundamental ideas are wrong they were
 took on conventional they didn't quite fit C++ in my opinion didn't serveimplicit conversions very well it didn't
 of mixed makes type arithmetic mix type computation computations very well a lotof stuff came out of the functional
 community and it that community didn't deal with multiple types in in the sameway as C++ does had more constraints on
 on what you could express and didn't have the draconian performancerequirements and basically we tried we
 tried very hard we had some successes but it just in the end wasn't didn'tcompile fast enough was too hard to use
 and didn't run fast enough unless you had optimizes that was beyond the stateof the art they still are so we had to
 do something else basically it was the idea that a set of parameters hasdefines a set of operations and you go
 through an interaction table just like for virtual functions and then you tryto optimize the interaction away to get
 performance and we just couldn't do all of that but get back to thestandardization we are standardizing C++
 on the ISO rules which a very open process people come in there's norequirements for education or experience


1:18:21
Speaker 1 :they start develop C++ and there's a
 hope when was the first standard established what is that like the ISOstandard is there committee that you're
 referring to she was a group of people what it was that like how often do youmeet what's the disguise I'll try and


1:18:39
Speaker 0 :explain that so sometime in early 1989
 two people one from IBM one from HP turned up in my office and told me Iwould like to standardize it PLAs PLAs
 this was a new idea to me and I pointed out that it wasn't finished yet itwasn't ready for former standardization
 and such and they say no beyond even gotten it you you really want to do thisour organizations depend on c++ we
 cannot depend on something that's owned by another corporation that might be acompetitor of course we could rely on
 you but you might get run over by a bus

1:19:32
Speaker 1 :right the old really needs to get this


1:19:34
Speaker 0 :out new it has to be standardized under
 formal rules and we are going to standardize it under ISO rules and youreally want to be part of it because
 basically otherwise we will do it ourselves and we know you can do itbetter so through a combination of
 arm-twisting and flattery Carolus started so in latein late 89 there was a meeting in DC at
 the x-ray no it was not ISO then it was an SI the American national standardwere doing
 we met there we were lectured on the rules of how to do when ANSI standardthere was about 25 of us there which
 apparently was a new record for that kind of meeting and some of the old seeguys that it's been standardizing see
 was there so we got some expertise in so the way this works is that it's an openprocess
 anybody can consign up if they pay the minimal fee which is about a thousanddollars still less then just a little
 bit more now and I think it's twelve hundred and eighty dollars it's not it'snot going to kill you
 and we have three meetings a year this is fairly standardwe try to meetings a year for a couple
 years that didn't work too well so three weeks is three one-week meetings a yearand you meet and you have taken meet
 technical discussions and then you bring proposals forward for votes the votesare done one person per one vote per
 organization so you can't have say IBM come in with 10 people and dominatethings that's not allowed and these


1:21:42
Speaker 1 :organizations that extends to the UC bus
 bus this yes this is all individuals or

1:21:47
Speaker 0 :

1:21:49
Speaker 1 :individuals I mean it's a it's a bunch
 of people in room deciding the design of a language based on which a lot of theworld's systems run right well I think


1:22:01
Speaker 0 :most people would agree it's better than
 if I decided it or better than if a single organization like agency decidesit I don't know if everyone agrees to


1:22:12
Speaker 1 :that by the way bureaucracies have their


1:22:18
Speaker 0 :critics - yes they they're that look
 standardization is not pleasant it's it's it's horrifying like democracy what

1:22:26
Speaker 1 :

1:22:27
Speaker 0 :we exactly as Churchill says democracy
 is the worst way except for or the others right and it's about say the samereforms
 but anyway so we meet and we we have these votes and that determines what thestandard is couple of years later we
 extended this so it became worldwide we have stand out of organizations that areactive in currently 15 to 20 countries
 and another fifteen to twenty are sort of lookingand and voting based on the rest of the
 work on it and we meet three times a year next week I'll be in CologneGermany spending a week doing
 standardization and we'll vote out the committee draft or c plus plus 20 whichgoes to the national standards
 committees for comments and requests for changes and improvements then we do thatand there's a second set of votes where
 hopefully everybody votes in favor this has happened several times the firsttime we finished we started in the first
 technical meeting was in 1990 the last was in 98 we voted it out that wassuspended that people used till 11:00 or
 a little bit past 11:00 and was an international standard all the countriesvoted in favor it took longer with 11
 I'll mention why what all the nations voted in favor and we work on the basisof consensus that is we do not want
 something that passes 6040 because then we're going to get dialects andopponents and people complain too much
 they don't complain so much but basically it no real effect the thestandards has been obeyed they have been
 working to make it easier to use many compilers many computers and all of thatkind of stuff and so the first the
 traditional with ISO standards to take ten years we did the first one and eightbrilliant and we thought we were going
 to do the next one and six because now we're good at it right it took 13 yeah

1:25:05
Speaker 1 :it was named Oh X he was named Oh X


1:25:06
Speaker 0 :

1:25:09
Speaker 1 :hoping that you would at least get it in
 within the single within the arts the

1:25:13
Speaker 0 :single day I thought we would get yeah I
 thought would gets six seven or eight the confidence of

1:25:18
Speaker 1 :

1:25:19
Speaker 0 :youth yes right well the point is that
 this was sort of like a second system effect that is we now knew how to do itand so we're going to do it much better
 and we got more ambitious and bish han dicho penguia furthermore there is thistendency because it's a 10-year cycle or
 age doesn't matter just before you're out to ship somebody has a bright ideayeah and so we really really must get
 that in we did that successfully with the STL we got the the standard Liarsall the STL stuff that that my base be I
 think it saved C++ it was beautiful yes and then people tried it with allour things and it didn't work so well
 they got things in but it wasn't as dramatic and it took longer and longerand longer
 so after C++ 11 which was a huge improvement and what basically what mostpeople are using today we decided ever
 again and so how do you avoid those slips andthe answer is that you shipped more
 often so that if you if you if you have a slip on the 10-year cycle by the timeyou know it's a slip there's 11 years
 till you get it yeah now with a three year cycle there is about three or fouryears till you get it like the delay
 between feature freeze and shipping so you always get one or two years more andso we were shipped fourteen on time we
 shipped seventeen on time and we ship we will ship 20 on timeit's it'll happen and furthermore this
 allow this gives a predictability that allows the implementers the compilerimplementers the library implementers so
 they have a target and they deliver on it 11 took two years before mostcompilers were good enough 14 most
 compilers were actually getting pretty good in 14 17 everybody shipped in 17well we are going to have at least
 almost everybody's ship almost everything in 20 and I know this becausethey're shipping in nineteen predictably
 this is good delivery on time is good and so yeah that's great those how it

1:28:03
Speaker 1 :

1:28:03
Speaker 0 :works there's a lot of features that


1:28:06
Speaker 1 :came in in C++ 11 there's a lot of
 features at the birth of C++ they were amazing and ideas with concepts in 2020what to you is the most justjust to you
 personally beautiful or just you sit

1:28:27
Speaker 0 :

1:28:28
Speaker 1 :back and think wow that's just nice and
 clean feature of C++ I have written two

1:28:36
Speaker 0 :papers for the history of programming
 languages conference which basically asked me such questionsand I'm writing a third one which I will
 deliver at the history of programming languages conference in London next yearso I've been thinking about that and
 there is one play answer constructors and destructors the way a constructorcan establish the environment for the
 use of the Java type for object and the destructor that cleans up any messes atthe end of it that is the key to C++
 that's why we don't have to use garbage collection that's how we can getpredictable performance that's how you
 can get the minimal overhead in many many cases and have really clean typesit's the idea of constructor destructor
 pairs sometimes it comes out under the name our high AIII resource acquisitionis initialization which is the idea that
 you grab resources and the constructor and release them and destructor it'salso the best example of why I shouldn't
 be in advertising I get the best idea and I call it resource acquisition isinitialization not the greatest naming
 I've ever heard so it's types

1:30:04
Speaker 1 :

1:30:06
Speaker 0 :

1:30:07
Speaker 1 :abstraction of types you said I want to
 create my own types so types is an essential part of C++ and making themefficient as the if it is the key part
 and GU the this is almost getting philosophical but the construction andthe destruction the creation of an
 instance of a type and the freeing of resources from that instance of a typeis what defines the object is uh that's
 like birth and death is what defines human life yeah that's right

1:30:47
Speaker 0 :by the way philosophy is important you
 can't do good language design without philosophy because what you aredetermining is what people can express
 this is very important by the way constructors destructors came into C++in 79 in about the second week of my
 work with what was then Corsi of the classesit is a fundamental idea next comes the
 fact that you need to control copying because once you control as you saysbirth and death you have to control
 taking copies which is another way of creating an object and finally you haveto be able to move things around so you
 get the move operations and that's the set of key operations you can define on

1:31:41
Speaker 1 :a C++ type inserts you those things are
 just a beautiful part of C++ that is at the core of it all yes you mentioned

1:31:51
Speaker 0 :

1:31:53
Speaker 1 :that you hope there will be one unified
 set of guidelines in the future for how to construct the programming language soperhaps not one programming language but
 a unification of how we build programming languages if you remember

1:32:10
Speaker 0 :the statement I I have some trouble
 remembering it but I know the origin of

1:32:15
Speaker 1 :that idea so maybe you can talk about
 sort of C++ has been improving there's been a lot of programming language doyou word is the arc of history taking us
 do you hope that there is a unification about the languages with which wecommunicate in the digital space well


1:32:31
Speaker 0 :III think that languages should be
 designed not by clobbering language features together and doing slightlydifferent versions or somebody else's
 ideas but through the creation of a set of principles rules of thumbs whateveryou call them I I made them for C++ and
 we're trying to teach people in the Standards Committee about these rulesbecause a lot of people come in and says
 I've got a great idea let's put it in languageand then you have to ask why does it fit
 in the language why does it fit in this language it may fit in on our languageand not here
 or may fit here not the other language so you have to work from a set ofprinciples and you have to develop that
 set of principles and it's one example that I sometimes remember is I wassitting down with some of the designers
 of common lisp and we are talking about languages and language features andobviously we didn't agree about anything
 because well this was not C++ and vice versa

1:33:54
Speaker 1 :too many parenthesis but suddenly we


1:33:55
Speaker 0 :started making progress I said I had
 this problem and I developed it according to these ideas and they saidwhat why we had that problem different
 problem and we develop it the same kind of principles and so we worked throughlarge chunks of C++ and large chunks of
 Common Lisp and figure out we actually had similar sets of principles of how todo it but the constraints on our designs
 were very different and the aims for the usage was very different but there wascommonality in the way you reason about
 language features and the fundamental principles you are trying to do so do

1:34:46
Speaker 1 :you think that's possible to so they're
 just like there is perhaps a unified theory of physics of the fundamentalforces of physics now I'm sure there is
 commonalities among the languages but there's also people involved you knowthat help drive these developing these
 languages do you have a hope or an

1:35:09
Speaker 0 :

1:35:10
Speaker 1 :optimism that there will be a
 unification if you think about physics and Einstein towards a simplifiedlanguage do you think that it's possible


1:35:23
Speaker 0 :let's remember sort of modern physics I
 think started with Galileo in the 1300s so they have had seven hundred years toget going
 modern computing started in about 49 we've got what's that 70 years they have10 10 times yeah
 and furthermore they they are not as bothered with people using physics theway we are worried about programming
 it's done by humans so each have problems and constraints the others havebut we are very immature compared to
 physics so I would look at sort of the philosophical level and and look forfundamental principles like you don't
 leak resources you shouldn't you don't take errors at runtime that you don'tneed to you don't violate some kind of
 type system there's many kinds of type systems but when you have one you don'tbreak it
 etc etc there will be quite a few and it will not be be the same for alllanguages but I think if we step back at
 some kind of philosophical level we can we would be able to agree on sets ofprinciples that applied to two sets of
 problem areas and within an area of use by in C++ this case what used to becalled systems programming the area
 between the hardware and the the the fluffier parts of the system you youmight very well see a convergence so
 these days you see rust having a adopted ra - and sometime accuses me forhaving borrowed it 20 years before they
 discovered it but it's we're seeing some kind of conversionconvergence here instead of relying on
 garbage collection all the time the garbage collection languages are doingthings like the dispose patterns and
 such that imitates some of the construction destruction stuff andthey're trying not to use the garbage
 collection all the time things like that so there's there there's conversion butI think we have to step back to the
 philosophical level and agree on principles and then we'll see someconversions convergences and it will be
 application domain-specific so a crazy

1:38:12
Speaker 1 :question but I work a lot with machine
 learning with deep learning I'm not sure if you touch that world that much butyou could think of programming is the
 thing that takes some input programming is the task of creating a program and aprogram takes some input and produces
 some output so machine learning systems train on data in order to be able totake an input and produce output but
 they're messy fuzzy things much like we as children grow up you know we takesome input make some output but we're
 noisy we mess up a lot we're definitely not reliable biological system or agiant mess so there's a sense in which
 machine learning is a kind of way of programming but just fuzzy it's very

1:39:06
Speaker 0 :

1:39:07
Speaker 1 :very very different than C++ because C++
 is a like it's just like you said it's extremely reliable it's efficient it'syou know you can you can measure you can
 test in a bunch of different ways with biological systems or machine learningsystems you can't say much except sort
 of empirically saying that ninety-nine point eight percent of the time it seems

1:39:33
Speaker 0 :to work what do you think about this


1:39:34
Speaker 1 :fuzzy kind of programming indeed even
 see it as programming is it solely and totally another kind of world I

1:39:44
Speaker 0 :I think it's a different kind of world
 and it is fuzzy and in my domain I don't like fuzziness that is people say thingslike they want everybody to be able to
 program but I don't want everybody to program my my aeroplane controls or thecar controls I want that to be done by
 engineers I want that to be done with people that are specifically educatedand trained for doing building things
 and it is not for everybody similarly a language like C++ is not foreverybody it is generated via sharp and
 effective tool for professionals basically and definitely for people whowho aim at some kind of precision you
 don't have people doing calculations without understanding math rightcounting on your fingers not going to
 cut it if you want to fly to the moon and so there are areas where andeighty-four percent accuracy rate 16
 percent false positive rate it's perfectly acceptable and where peoplewill probably get no more than 70 you
 said 98% I what I have seen is more like 84 and by by really a lot of blood sweatand tears you can get up to the 92 and a
 half right so this is fine if it is say pre-screening stuff before the humanlook at it it is not good enough for for
 life-threatening situations and so there's lots of areas where where thefuzziness is perfectly acceptable and
 good and better than humans cheaper than humans but it's not the kind ofengineering stuff I'm mostly interested
 in I worry a bit about machine learningthe context of cars you know much more
 about this than I do I worry too but I'm I'm sort of a an amateur here I've readsome of the papers but I have not ever
 done it and the the idea that scares me the most is the one I have heard and Idon't know how common it is that you
 have this AI system machine learning all of these trained neural nets and whenthey're something is too complicated
 they asked the human for help but human is reading a book or sleep and he has 30seconds or three seconds to figure out
 what the problem was that the AI system couldn't handle and do the right thingthis is scary
 I mean how do you do the cutter walk between the Machine and the human it's

1:42:58
Speaker 1 :very very difficult and for the designer
 or one of the most reliable efficient and powerful programming languages C++ Ican understand why that world is
 actually unappealing it is for most engineers to me it's extremely appealingbecause we don't know how to get that
 interaction right but I think it's possible but it's very very hard it is

1:43:25
Speaker 0 :and I was stating a problem no yes that


1:43:29
Speaker 1 :is the nostril I mean I would much
 rather never rely on a human if you're driving a nuclear reactor if you're oran autonomous vehicle it would it's much
 better to design systems written in C++ that never asked human for help let's

1:43:45
Speaker 0 :just get one fact in yeah all of this AI
 star Suns help us constructs so so that's one reason I have to keep aweather eye out or what's going on in
 that field but I will never become an expertarea but it's a good example of how you
 separate different areas of applications and you have to have different toolsdifferent principles and then they
 interact no major system today is written in one language and there aregood reasons for that when you look back


1:44:21
Speaker 1 :at your life work what is uh what is the
 moment what is a event creation that you're really proud ofthey say damn I did pretty good there is
 it as obvious as the creation of C++ and

1:44:41
Speaker 0 :so obvious I've spent a lot of time with
 C++ and there's a combination of a few good ideas a lot of hard work and a bitof luck and I try to get away from it a
 few times but I get tracked in again partly because I'm most effective inthis area and partly because what I do
 has much more impact if I do it in the context of C++ I I have four and a halfmillion people that pick it up tomorrow
 if I get something right if I did it in another field I would have to startlearning then I have to build it and
 then or see if anybody wants to use it one of the things that has kept me goingfor all of these years is one the good
 things that people do with it and the interesting things they do with it andalso I get to see a lot of interesting
 stuff and talk to a lot of interesting people I mean if it has just beenstatements on paper on a screen I I
 don't think I could have kept going but I get to see the telescopes up on MaunaKea and I actually went and see how Ford
 built cars and I got to JPL and see how they do the the Mars rovers there's somuch cool stuff going on and most of the
 cool stuff is done by pretty nice people and sometimes in very nice placescambridge sophia antipolis silicon
 valley yeah it's there there's more to it thanjust code but code is central on top of


1:46:29
Speaker 1 :the code are the people in very nice
 places well I think I speak for millions of people we aren't in saying thank youfor creating this language that so many
 systems are built on top of them that make a better world so thank you andthank you for talking today yeah thanks


